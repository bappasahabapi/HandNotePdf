# ЁЯФе02A-Open-Closed Principle (OCP)

The Open-Closed Principle (OCP) is one of the five SOLID principles of object-oriented design. It states that **software entities (classes, modules, functions, etc.) should be open for extension but closed for modification**. This means that you should be able to add new functionality to existing code without altering its source code.

### Key Concepts

- **Closed for Modification**: 
    - Existing code should not be changed when adding new features. This helps avoid introducing bugs and maintains the stability of the system.
    - **New features getting added to the software component should not have to modify the existing code.**
  
- **Open for Extension**: 
    - New functionalities can be added through new code, allowing the system to grow without modifying existing components.

### Real-World Analogy

A practical analogy to understand OCP is the **Nintendo Wii [Joy Stick] tool** gaming console:
- The Wii console comes with a basic controller and allows for various accessories (like the Wii Zapper and steering wheel) to be added without modifying the console itself.
- This design ensures that users can enhance their gaming experience without needing to alter the core system.

### Benefits of OCP

1. **Maintainability**: Reduces the risk of bugs by keeping existing code untouched.
2. **Scalability**: Facilitates easy addition of new features as requirements evolve.
3. **Reusability**: Encourages the reuse of existing modules and classes in different contexts.

### Implementation Example in Java

To illustrate OCP in practice, consider a scenario where you need to compare areas of different shapes:

#### Without OCP
```java
class Square {
    int height;
    int area() { return height * height; }
}

class OpenOpenExample {
    public int compareArea(Square a, Square b) {
        return a.area() - b.area();
    }
}
```
This approach requires modification if a new shape (like Circle) is introduced.

#### With OCP
By using an interface:
```java
interface Shape {
    int area();
}

class Circle implements Shape {
    int radius;
    int area() { return (int)(Math.PI * radius * radius); }
}

class Square implements Shape {
    int height;
    int area() { return height * height; }
}

class OpenClosedExample {
    public int compareArea(Shape a, Shape b) {
        return a.area() - b.area();
    }
}
```
In this design, you can add new shapes without modifying existing code, adhering to the Open-Closed Principle.

### Conclusion



The Open-Closed Principle encourages developers to design systems that are robust and adaptable.

By focusing on extending functionality rather than modifying existing code, developers can create more maintainable and scalable applications. 

In future sessions, we will explore practical coding examples that demonstrate OCP in action.

# ЁЯФе02B-ржУржкрзЗржи-ржХрзНрж▓рзЛржЬржб ржкрзНрж░рж┐ржирзНрж╕рж┐ржкрж▓: ржХрзЛржб ржЙржжрж╛рж╣рж░ржг

### ржкрж░рж┐ржЪрж┐рждрж┐
ржЖржорж░рж╛ ржПржХржЯрж┐ ржХрзЛржб ржЙржжрж╛рж╣рж░ржг ржжрзЗржЦржм ржпрж╛ ржПржЗ ржирзАрждрж┐рж░ ржмрж╛рж╕рзНрждржмрж╛ржпрж╝ржиржХрзЗ ржЪрж┐рждрзНрж░рж┐ржд ржХрж░ржмрзЗред

### ржкрзНрж░рзЗржХрзНрж╖рж╛ржкржЯ

ржзрж░рж┐, **One State** ржПржХржЯрж┐ ржмрзАржорж╛ ржХрзЛржорзНржкрж╛ржирж┐ ржпрж╛ ржорзВрж▓ржд рж╕рзНржмрж╛рж╕рзНржерзНржп ржмрзАржорж╛рж░ рж╕рж╛ржерзЗ ржЬржбрж╝рж┐рждред рждрж╛ржжрзЗрж░ ржмрзАржорж╛ ржЧржгржирж╛ ржПржХржЯрж┐ Java рж▓рж╛ржЗржмрзНрж░рзЗрж░рж┐рждрзЗ ржХрзЛржб ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред 

#### ржХрзЛржб рж╕рзНржирж┐ржкрзЗржЯ

ржПржЦрж╛ржирзЗ ржПржХржЯрж┐ ржХрзЛржб рж╕рзНржирж┐ржкрзЗржЯ рж░ржпрж╝рзЗржЫрзЗ ржпрж╛ ржкрзНрж░рж┐ржорж┐ржпрж╝рж╛ржо ржбрж┐рж╕ржХрж╛ржЙржирзНржЯ ржХрзНржпрж╛рж▓ржХрзБрж▓рзЗрж╢ржи ржжрзЗржЦрж╛ржпрж╝:

```java
class InsurancePremiumDiscountCalculator {
    public double calculatePremiumDiscountPercent(HealthInsuranceCustomerProfile profile) {
        if (profile.isLoyalCustomer()) {
            return 10.0; // Loyal customer discount
        }
        return 0.0; // No discount
    }
}
```

- **HealthInsuranceCustomerProfile** ржХрзНрж▓рж╛рж╕рзЗ ржПржХржЯрж┐ `isLoyalCustomer()` ржкржжрзНржзрждрж┐ рж░ржпрж╝рзЗржЫрзЗ ржпрж╛ рж╕рждрзНржп (true) ржлрзЗрж░ржд ржжрзЗржпрж╝ ржпржжрж┐ ржЧрзНрж░рж╛рж╣ржХ ржПржХржЬржи ржмрж┐рж╢рзНржмрж╕рзНржд ржЧрзНрж░рж╛рж╣ржХ рж╣ржпрж╝, ржЕржирзНржпржерж╛ржпрж╝ ржорж┐ржерзНржпрж╛ (false) ржлрзЗрж░ржд ржжрзЗржпрж╝ред

### ржирждрзБржи ржЪрзНржпрж╛рж▓рзЗржЮрзНржЬ

ржзрж░рж┐, One State ржХрзЛржорзНржкрж╛ржирж┐ ржПржХржЯрж┐ ржирждрзБржи ржЧрж╛ржбрж╝рж┐ ржмрзАржорж╛ ржХрзЛржорзНржкрж╛ржирж┐ ржЕржзрж┐ржЧрзНрж░рж╣ржг ржХрж░рзЗ ржПржмржВ рждрж╛ржжрзЗрж░ ржЯрзНржпрж╛ржЧрж▓рж╛ржЗржи ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рзЗ: "ржЖржкржирж╛рж░ рж╕рзНржмрж╛рж╕рзНржерзНржп ржПржмржВ ржЧрж╛ржбрж╝рж┐ ржмрзАржорж╛рж░ ржЬржирзНржп рж╕ржмржХрж┐ржЫрзБ"ред ржПржЦржи ржЖржорж╛ржжрзЗрж░ ржЧрж╛ржбрж╝рж┐ ржмрзАржорж╛рж░ ржбрж┐рж╕ржХрж╛ржЙржирзНржЯржУ рж╕ржорж░рзНржержи ржХрж░рждрзЗ рж╣ржмрзЗред

#### ржирждрзБржи ржХрзНрж▓рж╛рж╕ ржпрзЛржЧ ржХрж░рж╛

ржЖржорж░рж╛ ржПржХржЯрж┐ ржирждрзБржи ржХрзНрж▓рж╛рж╕ ржпрзБржХрзНржд ржХрж░рж┐: **VehicleInsuranceCustomerProfile**ред ржПржЯрж┐ **HealthInsuranceCustomerProfile** ржПрж░ ржорждрзЛ ржПржмржВ ржПрж░ `isLoyal()` ржкржжрзНржзрждрж┐ рж░ржпрж╝рзЗржЫрзЗред

```java
class VehicleInsuranceCustomerProfile {
    public boolean isLoyal() {
        // Logic to determine loyalty
    }
}
```

### рж╕ржорж╕рзНржпрж╛

ржПржЦржи ржЖржорж╛ржжрзЗрж░ **InsurancePremiumDiscountCalculator** ржХрзНрж▓рж╛рж╕ржЯрж┐ ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рждрзЗ рж╣ржмрзЗ, ржХрж╛рж░ржг ржПрж░ `calculate` ржкржжрзНржзрждрж┐ ржмрж░рзНрждржорж╛ржирзЗ рж╢рзБржзрзБржорж╛рждрзНрж░ **HealthInsuranceCustomerProfile** ржЕржмржЬрзЗржХрзНржЯ ржЧрзНрж░рж╣ржг ржХрж░рзЗред 

#### OCP рж▓ржЩрзНржШржи

- ржирждрзБржи ржмрзИрж╢рж┐рж╖рзНржЯрзНржп ржпрзЛржЧ ржХрж░рж╛рж░ ржЬржирзНржп ржЖржорж╛ржжрзЗрж░ ржмрж┐ржжрзНржпржорж╛ржи ржХрзЛржбрзЗ ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рждрзЗ рж╣ржЪрзНржЫрзЗ, ржпрж╛ ржУржкрзЗржи-ржХрзНрж▓рзЛржЬржб ржкрзНрж░рж┐ржирзНрж╕рж┐ржкрж▓рзЗрж░ ржмрж┐рж░рзБржжрзНржзрзЗ ржпрж╛рзЯред
- ржпржжрж┐ ржЖржорж░рж╛ ржмрж╛ржбрж╝рж┐рж░ ржмрзАржорж╛ржУ рж╕ржорж░рзНржержи ржХрж░рждрзЗ ржЪрж╛ржЗ, рждрж╛рж╣рж▓рзЗ ржЖржмрж╛рж░ ржХрзЛржб ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рждрзЗ рж╣ржмрзЗред

### ржбрж┐ржЬрж╛ржЗржи ржкрзБржирж░рзНржЧржаржи

ржЖржорж░рж╛ ржЖржорж╛ржжрзЗрж░ ржбрж┐ржЬрж╛ржЗржиржЯрж┐ ржкрзБржирж░рзНржЧржаржи ржХрж░рж┐:

1. **CustomerProfile** ржирж╛ржорзЗ ржПржХржЯрж┐ ржирждрзБржи ржЗржирзНржЯрж╛рж░ржлрзЗрж╕ рждрзИрж░рж┐ ржХрж░рж┐ред
2. ржПржЗ ржЗржирзНржЯрж╛рж░ржлрзЗрж╕рзЗ ржПржХржЯрж┐ ржорж╛рждрзНрж░ ржкржжрзНржзрждрж┐ ржерж╛ржХржмрзЗ: `isLoyalCustomer()`ред
3. ржЙржнржпрж╝ **HealthInsuranceCustomerProfile** ржПржмржВ **VehicleInsuranceCustomerProfile** ржХрзНрж▓рж╛рж╕ ржПржЗ рж╕рж╛ржзрж╛рж░ржг ржЗржирзНржЯрж╛рж░ржлрзЗрж╕ржЯрж┐ ржмрж╛рж╕рзНрждржмрж╛ржпрж╝ржи ржХрж░ржмрзЗред

```java
interface CustomerProfile {
    boolean isLoyalCustomer();
}

class HealthInsuranceCustomerProfile implements CustomerProfile {
    public boolean isLoyalCustomer() {
        // Logic for health insurance loyalty
    }
}

class VehicleInsuranceCustomerProfile implements CustomerProfile {
    public boolean isLoyalCustomer() {
        // Logic for vehicle insurance loyalty
    }
}
```

### ржирждрзБржи ржХрзНржпрж╛рж▓ржХрзБрж▓рзЗржЯрж░ ржХрзНрж▓рж╛рж╕

ржПржЦржи **InsurancePremiumDiscountCalculator** ржХрзНрж▓рж╛рж╕рзЗрж░ ржкржжрзНржзрждрж┐ ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рж┐:

```java
class InsurancePremiumDiscountCalculator {
    public double calculatePremiumDiscountPercent(CustomerProfile profile) {
        if (profile.isLoyalCustomer()) {
            return 10.0; // Loyal customer discount
        }
        return 0.0; // No discount
    }
}
```

### рж╕рзБржмрж┐ржзрж╛

- ржПржЦржи ржЖржорж░рж╛ ржпржжрж┐ ржмрж╛ржбрж╝рж┐рж░ ржмрзАржорж╛рж░ ржЬржирзНржп ржПржХржЯрж┐ ржирждрзБржи ржХрзНрж▓рж╛рж╕ рждрзИрж░рж┐ ржХрж░рж┐, ржпрзЗржоржи **HomeInsuranceCustomerProfile**, ржПржЯрж┐ рж╢рзБржзрзБржорж╛рждрзНрж░ **CustomerProfile** ржЗржирзНржЯрж╛рж░ржлрзЗрж╕ржЯрж┐ ржмрж╛рж╕рзНрждржмрж╛ржпрж╝ржи ржХрж░ржмрзЗред
- ржЖржорж╛ржжрзЗрж░ **InsurancePremiumDiscountCalculator** ржХрзНрж▓рж╛рж╕рзЗ ржХрзЛржирзЛ ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рждрзЗ рж╣ржмрзЗ ржирж╛ред

### ржЙржкрж╕ржВрж╣рж╛рж░

ржЖржорж░рж╛ ржжрзЗржЦрзЗржЫрж┐ ржХрж┐ржнрж╛ржмрзЗ ржбрж┐ржЬрж╛ржЗржи ржкрзБржирж░рзНржЧржаржи ржХрж░рзЗ ржУржкрзЗржи-ржХрзНрж▓рзЛржЬржб ржкрзНрж░рж┐ржирзНрж╕рж┐ржкрж▓ ржЕржирзБржпрж╛ржпрж╝рзА ржХрж╛ржЬ ржХрж░рж╛ ржпрж╛ржпрж╝ред ржкрзНрж░ржержорзЗ ржбрж┐ржЬрж╛ржЗржиржЯрж┐ OCP ржЕржирзБрж╕рж░ржг ржХрж░ржЫрж┐рж▓ ржирж╛, ржХрж┐ржирзНрждрзБ ржкрзБржирж░рзНржЧржаржирзЗрж░ ржорж╛ржзрзНржпржорзЗ ржПржЯрж┐ OCP-рж░ рж╕рж╛ржерзЗ рж╕рж╛ржоржЮрзНржЬрж╕рзНржпржкрзВрж░рзНржг рж╣ржпрж╝рзЗ ржЙржарзЗржЫрзЗред 

ржПржЦржи ржбрж┐ржЬрж╛ржЗржиржЯрж┐ ржнржмрж┐рж╖рзНржпрждрзЗрж░ ржПржХрзНрж╕ржЯрзЗржирж╢ржирзЗрж░ ржЬржирзНржп ржЖрж░ржУ рж╢ржХрзНрждрж┐рж╢рж╛рж▓рзА ржПржмржВ ржХрж╛рж░рзНржпржХрж░рзАред 

ржПржЯрж┐ ржЫрж┐рж▓ ржУржкрзЗржи-ржХрзНрж▓рзЛржЬржб ржкрзНрж░рж┐ржирзНрж╕рж┐ржкрж▓рзЗрж░ ржПржХржЯрж┐ ржЙржжрж╛рж╣рж░ржгред 

# ЁЯФе02C-Key Takeaways from the Open-Closed Principle Code Example

### Introduction

We will summarize the key takeaways from the previous code example that illustrated the Open-Closed Principle (OCP). 

### Principal Benefits of the New Design

1. **Ease of Adding New Features**
   - The primary benefit of adhering to the Open-Closed Principle is the ease with which new features can be added to the system.
   - This ease translates into **cost savings** for development and testing.

#### Cost Savings Explained

- If we do not follow OCP, adding new features **often requires modifying existing code.** 
- Each modification increases the time spent on testing and quality assurance to ensure that no new bugs are introduced into the existing codebase.
- In contrast, when following OCP, testing new code is simpler and less time-consuming than running a full regression test suite on existing code.
- This principle is well-known among QA testers, who emphasize its importance in maintaining software quality.

### Additional Benefits

2. **Decoupling of Components**
   - By redesigning our system to conform to OCP, we inadvertently achieved a higher degree of **loose coupling** between components.
   - This decoupling aligns with the **Single Responsibility Principle (SRP)**, as each component now has a clearer purpose and responsibility.

### Interconnectedness of SOLID Principles

- It is crucial to understand that the SOLID principles are intertwined and interdependent. 
- They are most effective when applied together, providing a holistic approach to software design.

### Cautionary Note

- **Do Not Follow OCP Blindly**: 
  - While OCP is beneficial, blindly applying it can lead to an excessive number of classes, complicating your overall design.
  - For instance, if you need to fix a bug and believe that modifying existing code is necessary for an effective fix, do so without hesitation.
  - Avoid overhauling your design solely for bug fixes unless you notice recurring issues that could be mitigated by a redesign.

### Subjective Application of OCP

- Deciding when and where to apply the Open-Closed Principle is subjective rather than objective. 
- Use your judgment based on the specific context of your project.

### Conclusion

- Re-designed code to make it follow OCP
- Following OCP can lead to cost benifits in the long run.
- OPC and SRP can work together to achieve a better design.
- Do not apply the OCPblindly and introduce unwanted complexity to your code.

The lessons learned from our code example related to the Open-Closed Principle. Understanding these key takeaways will help you apply OCP effectively in your future designs. 

